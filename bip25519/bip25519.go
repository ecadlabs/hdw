/*
Package bip25519 deals with BIP32-Ed25519 keys as specified in paper by Khovratovich and Law.
Private key generated by this package are in an expanded form and can't be used
with most of standard crypto tools and libraries
*/
package bip25519

import (
	"crypto"
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/binary"
	"fmt"
	"hash"

	"filippo.io/edwards25519"
	"github.com/ecadlabs/hdw"
	"github.com/ecadlabs/hdw/bip25519/ex25519"
)

const (
	// MinSeedSize is the minimal allowed seed byte length
	MinSeedSize = 32
)

// PrivateKey is the extended Ed25519 private key. It implements hdw.PrivateKey
type PrivateKey struct {
	ex25519.PrivateKey
	ChainCode []byte
}

const ed25519Key = "ed25519 seed"

// Mode is the mode of root key generation
type Mode int

const (
	ModeDefault Mode = iota // NewKeyFromSeed will return nil if the seed gave an unusable hash as specified in original paper by Khovratovich and Law
	ModeRetry               // NewKeyFromSeed will rehash the result if the first attempt gave an unusable hash
	ModeForce               // Clear undesired bits of the hash and continue
)

//
type Options struct {
	Mode Mode
	HMAC bool // Use HMAC with "ed25519 seed" phrase as a key instead of plain SHA512/SHA256 to generate the root key
}

func computeHMAC(data []byte, h func() hash.Hash, key []byte) []byte {
	hmac := hmac.New(h, key)
	hmac.Write(data)
	return hmac.Sum(nil)
}

func newKeyFromSeed(seed []byte, opt *Options) *PrivateKey {
	keyGen := func(data []byte, h func() hash.Hash) []byte {
		var sum hash.Hash
		if opt != nil && opt.HMAC {
			sum = hmac.New(h, []byte(ed25519Key))
		} else {
			sum = h()
		}
		sum.Write(data)
		return sum.Sum(nil)
	}

	h := keyGen(seed, sha512.New)
	switch {
	case opt != nil && opt.Mode == ModeRetry:
		for h[31]&0x20 != 0 {
			h = keyGen(h, sha512.New)
		}
	case opt != nil && opt.Mode == ModeForce:
		h[31] &= 0xdf
	default:
		if h[31]&0x20 != 0 {
			return nil
		}
	}

	h[0] &= 0xf8
	h[31] = (h[31] & 0x7f) | 0x40

	tmp := make([]byte, len(seed)+1)
	tmp[0] = 1
	copy(tmp[1:], seed)
	chain := keyGen(tmp, sha256.New)

	priv, err := ex25519.NewKeyFromBytes(h)
	if err != nil {
		panic(err)
	}
	return &PrivateKey{
		PrivateKey: priv,
		ChainCode:  chain,
	}
}

// NewKeyFromSeed generates the root key from the seed
func NewKeyFromSeed(seed []byte, opt *Options) *PrivateKey {
	if len(seed) < MinSeedSize {
		panic(fmt.Sprintf("bip25519: bad seed size %d", len(seed)))
	}
	return newKeyFromSeed(seed, opt)
}

func mul8(a []byte) {
	var m uint16
	for i := 0; i < len(a); i++ {
		m += uint16(a[i]) << 3
		a[i] = byte(m & 0xff)
		m >>= 8
	}
}

func add(a, b []byte) {
	var m uint16
	for i := 0; i < len(a); i++ {
		m += uint16(a[i]) + uint16(b[i])
		a[i] = byte(m & 0xff)
		m >>= 8
	}
}

// Derive returns a child key of the receiver using a single index
func (p *PrivateKey) Derive(index uint32) (hdw.PrivateKey, error) {
	var (
		z []byte
		f []byte
	)

	if index&hdw.Hard != 0 {
		// hardened
		buf := make([]byte, 69)
		copy(buf[1:], p.PrivateKey[:ex25519.ExpandedKeySize])
		binary.LittleEndian.PutUint32(buf[65:], index)
		z = computeHMAC(buf, sha512.New, p.ChainCode)
		buf[0] = 1
		f = computeHMAC(buf, sha512.New, p.ChainCode)
	} else {
		buf := make([]byte, 37)
		buf[0] = 2
		copy(buf[1:], p.PrivateKey[ex25519.ExpandedKeySize:])
		binary.LittleEndian.PutUint32(buf[33:], index)
		z = computeHMAC(buf, sha512.New, p.ChainCode)
		buf[0] = 3
		f = computeHMAC(buf, sha512.New, p.ChainCode)
	}

	var k [64]byte
	copy(k[:], z[:28])
	mul8(k[:32])                   // kl *= 8
	add(k[:32], p.PrivateKey[:32]) // kl += kpl
	copy(k[32:], z[32:])
	add(k[32:], p.PrivateKey[32:]) // kr += kpr

	priv, err := ex25519.NewKeyFromBytes(k[:])
	if err != nil {
		panic(err)
	}
	return &PrivateKey{
		PrivateKey: priv,
		ChainCode:  f[32:],
	}, nil
}

// Chain returns the chain code
func (p *PrivateKey) Chain() []byte {
	return p.ChainCode
}

// Naked returns the naked private key of type ex25519.PrivateKey.
// This type implements crypto.Signer but it can't be used with the standard crypto library
// as it keeps the key data in expanded form which is equivalent to the Ed25519 post-hash 512 bit value
func (p *PrivateKey) Naked() crypto.PrivateKey {
	return p.PrivateKey
}

func (p *PrivateKey) bytes() []byte {
	out := make([]byte, 96)
	copy(out, p.PrivateKey)
	copy(out[64:], p.ChainCode)
	return out
}

func keyFromBytes(src []byte) (*PrivateKey, error) {
	if len(src) != 96 {
		return nil, fmt.Errorf("bip25519: bad BIP32-ED25519 private key size %d", len(src))
	}
	out := PrivateKey{
		ChainCode: make([]byte, 32),
	}
	var err error
	out.PrivateKey, err = ex25519.NewKeyFromBytes(src[:64])
	if err != nil {
		panic(err)
	}
	copy(out.ChainCode, src[64:])
	return &out, nil
}

// PublicKey is the extended Ed25519 public key. It implements hdw.PublicKey
type PublicKey struct {
	ed25519.PublicKey
	ChainCode []byte
}

// ExtendedPublic returns the extended public key corresponding to the receiver
func (p *PrivateKey) ExtendedPublic() hdw.PublicKey {
	return &PublicKey{
		PublicKey: p.Public().(ed25519.PublicKey),
		ChainCode: p.ChainCode,
	}
}

// Derive returns a child key of the receiver using a full path
func (s *PrivateKey) DerivePath(path hdw.Path) (hdw.PrivateKey, error) {
	if k, err := hdw.Derive(s, path); err != nil {
		return nil, err
	} else {
		return k.(hdw.PrivateKey), nil
	}
}

// Chain returns the chain code
func (p *PublicKey) Chain() []byte {
	return p.ChainCode
}

// Naked returns the naked private key that can be used with the standard Go crypto library
func (p *PublicKey) Naked() crypto.PublicKey {
	return p.PublicKey
}

// Derive returns a child key of the receiver using a single index
func (p *PublicKey) Derive(index uint32) (hdw.PublicKey, error) {
	if index&hdw.Hard != 0 {
		return nil, hdw.ErrHardenedPublic
	}

	buf := make([]byte, 37)
	buf[0] = 2
	copy(buf[1:], p.PublicKey)
	binary.LittleEndian.PutUint32(buf[33:], index)
	z := computeHMAC(buf, sha512.New, p.ChainCode)
	buf[0] = 3
	f := computeHMAC(buf, sha512.New, p.ChainCode)

	var m [32]byte
	copy(m[:], z[:28])
	mul8(m[:]) // m *= 8

	s, err := edwards25519.NewScalar().SetCanonicalBytes(m[:])
	if err != nil {
		panic(err)
	}
	a, err := (&edwards25519.Point{}).SetBytes(p.PublicKey)
	if err != nil {
		panic(err)
	}
	point := (&edwards25519.Point{}).ScalarBaseMult(s)
	point.Add(point, a)

	return &PublicKey{
		PublicKey: point.Bytes(),
		ChainCode: f[32:],
	}, nil
}

// Derive returns a child key of the receiver using a full path
func (s *PublicKey) DerivePath(path hdw.Path) (hdw.PublicKey, error) {
	if k, err := hdw.Derive(s, path); err != nil {
		return nil, err
	} else {
		return k.(hdw.PublicKey), nil
	}
}
